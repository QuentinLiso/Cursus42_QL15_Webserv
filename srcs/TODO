1. 

(HttpRequest class) At parsing, read the request : check if character is allowed 

Allowed URI path ->			%21 %24 %26 %27 %28 %29 %2A %2B %2C - . / %3A %3B %3D ? %40 %5B %5D 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z ~
Allowed URI query ->		%20 %21 %24 %26 %27 %28 %29 %2A + %2B %2C - . %2F %3A %3B = %3D ? %40 %5B %5D 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z ~
Allowed Header name ->		- . 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z ~
Allowed Header value ->		%20 %21 %22 %24 %26 %27 %28 %29 %2A %2B %2C - . %3A %3B %3D %40 %5B %5D 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z ~

Allowed URI path ->
	Accepted -> %20 ! %21 $ %24 & %26 ’ %27 ( %28 ) %29 * %2A + %2B , %2C - %2D . %2E / : %3A ; %3B = %3D @ %40 0 %30 1 %31 2 %32 3 %33 4 %34 5 %35 6 %36 7 %37 8 %38 9 %39 A %41 B %42 C %43 D %44 E %45 F %46 G %47 H %48 I %49 J %4A K %4B L %4C M %4D N %4E O %4F P %50 Q %51 R %52 S %53 T %54 U %55 V %56 W %57 X %58 Y %59 Z %5A _ %5F a %61 b %62 c %63 d %64 e %65 f %66 g %67 h %68 i %69 j %6A k %6B l %6C m %6D n %6E o %6F p %70 q %71 r %72 s %73 t %74 u %75 v %76 w %77 x %78 y %79 z %7A ~ %7E
	Rejected -> %00 %01 %02 %03 %04 %05 %06 %07 %08 %09 %0A %0B %0C %0D %0E %0F %10 %11 %12 %13 %14 %15 %16 %17 %18 %19 %1A %1B %1C %1D %1E %1F %7F SPACE " %22 # %23 % %25 %2F < %3C > %3E ? %3F [ %5B \ %5C ] %5D ^ %5E ` %60 { %7B | %7C } %7D



(HttpRequest class) At parsing, after previous step, decode characters :

URI path ->			! $ & ’ ( ) * + , - . / : ; = @ [ ] 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z ~
URI query ->		SPACE ! $ & ’ ( ) * + , - . / : ; = ? @ [ ] 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z ~
Header name ->		- . 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z ~
Header value ->		SPACE ! " $ & ’ ( ) * + , - . : ; = @ [ ] 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z ~


(HttpResponse class) 

URI path -> sanitize the path, remove the forbidden /../ \\..\\ etc. and call stat() on the file with literal. Allowed characters are checked at parsing time so no additional check here



-----------------------------------------------------------------------------------------------------------

Can you please validate my control flow then ? It would help me a lot to synthesize :

Uri :
Read until ‘?’ to split URI path from URI query

URI path :
Declare a fixed size buffer
Check for maximum path size
Loop over the sequence of characters :
If invalid char -> bad request
If % encoded -> check valid %-encoding, decode, check that the decoded is in the percent-encoded allowed set (if not, bad request) and put the decoded inside the buffer
If valid char -> put the character as-is inside the buffer 
Pass the buffer to the URi path variable inside the HttpRequest class

URI query
Declare a fixed size unsigned char buffer
Check for maximum query size
Loop over the sequence of characters :
If invalid char-> bad request
If percent encoded -> convert %XX into raw bytes (error if X is not an hex character) and put the decoded bytes into the buffer
If valid char -> add as-is to the buffer
Then, loop over the bytes of the buffer :
If invalid utf8 sequence -> bad request
If control char -> bad request
Pass the buffer to the URi query variable inside the HttpRequest class